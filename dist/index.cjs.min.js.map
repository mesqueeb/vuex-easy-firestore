{"version":3,"file":"index.cjs.min.js","sources":["../src/utils/nanomerge.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/debounceHelper.js","../src/utils/objectFlattenToPaths.js","../src/module/actions.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/errorCheck.js","../src/module/index.js","../src/index.js"],"sourcesContent":["var nanoclone = require('nanoclone').default\n\nfunction toArray (object) {\n  var result = []\n\n  for (var i = 0; i < object.length; ++i) {\n    result.push(object[i])\n  }\n\n  return result\n}\n\nvar types = [\n  {\n    name: 'primitive',\n\n    is: function (el) {\n      var type = typeof el\n\n      return (type === 'number' || type === 'string' || type === 'boolean')\n    },\n\n    default: 'default',\n\n    merge: {\n      default: function (merger, a, b) {\n        return b\n      }\n    }\n  },\n\n  {\n    name: 'object',\n\n    is: function (el) {\n      return el !== null && (typeof el === 'object')\n    },\n\n    default: 'deep',\n\n    merge: {\n      deep: function (merger, a, b) {\n        var result = {}\n\n        var keys = {\n          a: Object.keys(a),\n          b: Object.keys(b)\n        }\n\n        keys.a.concat(keys.b).forEach(function (key) {\n          result[key] = merger(a[key], b[key])\n        })\n\n        return result\n      }\n    }\n  },\n\n  {\n    name: 'array',\n\n    is: function (el) {\n      return Array.isArray(el)\n    },\n\n    default: 'replace',\n\n    merge: {\n      merge: function (merger, a, b) {\n        var result = []\n\n        for (var i = 0; i < Math.max(a.length, b.length); ++i) {\n          result.push(merger(a[i], b[i]))\n        }\n\n        return result\n      },\n\n      replace: function (merger, a, b) {\n        return nanoclone(b)\n      },\n\n      concat: function (merger, a, b) {\n        return (([]).concat(a)).concat(b)\n      }\n    }\n  }\n]\n\nfunction merge (config) {\n  if (!config) {\n    config = {}\n  }\n\n  config = {\n    strategy: config.strategy || {}\n  }\n\n  function determineType (a, b) {\n    for (var i = types.length - 1; i >= 0; --i) {\n      var type = types[i]\n\n      if (type.is(a) && type.is(b)) {\n        return type\n      } else if (type.is(a) || type.is(b)) {\n        break\n      }\n    }\n\n    return null\n  }\n\n  function merger (a, b) {\n    if (b === void 0) {\n      return nanoclone(a)\n    }\n\n    var type = determineType(a, b)\n\n    if (!type) {\n      return nanoclone(b)\n    }\n\n    var strategy = config.strategy[type.name] || type.default\n\n    return type.merge[strategy](merger, a, b)\n  }\n\n  return function () {\n    var elements = toArray(arguments)\n\n    return elements.reduceRight(function (result, element) {\n      return merger(element, result)\n    })\n  }\n}\n\nfunction wrapper () {\n  var args = toArray(arguments)\n\n  // custom config\n  if (args.length === 1) {\n    return merge(args[0])\n  }\n\n  return merge().apply(null, args)\n}\n\nexport default wrapper\n// module.exports = wrapper\n","import { isObject } from 'is-what'\n// import deepmerge from 'nanomerge'\nimport deepmerge from './nanomerge'\n\nfunction merge (...params) {\n  let l = params.length\n  for (l; l > 0; l--) {\n    const item = params[l - 1]\n    if (!isObject(item)) {\n      console.error('trying to merge a non-object: ', item)\n      return item\n    }\n  }\n  return deepmerge(...params)\n}\n\nexport default merge\n","\nexport default {\n  firestorePath: '',\n    // The path to a collection or doc in firestore. You can use `{userId}` which will be replaced with the user Id.\n  firestoreRefType: '',\n    // `'collection'` or `'doc'`. Depending on your `firestorePath`.\n  moduleName: '',\n    // The module name. Can be nested, eg. `'user/items'`\n  statePropName: '',\n    // The name of the property where the docs or doc will be synced to. If left blank it will be synced on the state of the module. (Please see [Sync directly to module state](#sync-directly-to-module-state) for more info)\n\n  // Related to the 2-way sync:\n  sync: {\n    where: [],\n    orderBy: [],\n    fillables: [],\n    guard: [],\n    // HOOKS for local changes:\n    insertHook: function (updateStore, doc, store) { return updateStore(doc) },\n    patchHook: function (updateStore, doc, store) { return updateStore(doc) },\n    deleteHook: function (updateStore, id, store) { return updateStore(id) },\n  },\n\n  // When items on the server side are changed:\n  serverChange: {\n    defaultValues: {},\n    // HOOKS for changes on SERVER:\n    addedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    modifiedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    removedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n  },\n\n  // When items are fetched through `dispatch('module/fetch', filters)`.\n  fetch: {\n    // The max amount of documents to be fetched. Defaults to 50.\n    docLimit: 50,\n  },\n\n  // You can also add custom state/getters/mutations/actions. These will be added to your module.\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n}\n","\nexport default {\n  _sync: {\n    signedIn: false,\n    patching: false,\n    syncStack: {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    },\n    fetched: [],\n    stopPatchingTimeout: null\n  }\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state._sync.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, doc)\n    } else {\n      this._vm.$set(state, doc.id, doc)\n    }\n  },\n  PATCH_DOC (state, doc) {\n    // When patching in single 'doc' mode\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') {\n      // if no target prop is the state\n      if (!state._conf.statePropName) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined || !isObject(state[key]) || !isObject(doc[key]))\n            ? doc[key]\n            : merge(state[key], doc[key])\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state._conf.statePropName] will always be an empty object by default\n      state[state._conf.statePropName] = merge(state[state._conf.statePropName], doc)\n      return\n    }\n    // Patching in 'collection' mode\n    // get the doc ref\n    const docRef = (state._conf.statePropName)\n      ? state[state._conf.statePropName][doc.id]\n      : state[doc.id]\n    // Merge if exists\n    const newVal = (docRef === undefined || !isObject(docRef) || !isObject(doc))\n      ? doc\n      : merge(docRef, doc)\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, newVal)\n    } else {\n      this._vm.$set(state, doc.id, newVal)\n    }\n  },\n  DELETE_DOC (state, id) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$delete(state[state._conf.statePropName], id)\n    } else {\n      this._vm.$delete(state, id)\n    }\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","import { isObject } from 'is-what'\n\nfunction retrievePaths (object, path, result) {\n  if (!isObject(object) || !Object.keys(object).length) {\n    if (!path) return object\n    result[path] = object\n    return result\n  }\n  return Object.keys(object).reduce((carry, key) => {\n    const pathUntilNow = (path)\n      ? path + '.'\n      : ''\n    const newPath = pathUntilNow + key\n    const extra = retrievePaths(object[key], newPath, result)\n    return Object.assign(carry, extra)\n  }, {})\n}\n\nexport default function (object) {\n  const result = {}\n  return retrievePaths(object, null, result)\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\nimport flattenToPaths from '../utils/objectFlattenToPaths'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], doc} = {ids: [], doc: {}}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) return console.log('ids needs to be an array')\n    if (id) ids.push(id)\n    if (doc.id) delete doc.id\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, doc)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state._sync.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(state._sync.syncStack.updates[id],\n                syncStackItems[id])\n      state._sync.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state._sync.syncStack.deletions.concat(syncStackIds)\n    state._sync.syncStack.deletions = deletions\n\n    if (!state._sync.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state._sync.syncStack.inserts.concat(syncStack)\n    state._sync.syncStack.inserts = inserts\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state._sync.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      state._sync.syncStack.debounceTimer = debounceTimer\n    }\n    state._sync.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state._sync.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state._sync.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = flattenToPaths(item.fields)\n      console.log('fields â†’ ', fields)\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state._sync.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.deletions = deletionsLeft\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state._sync.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.inserts = insertsLeft\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    state._sync.syncStack.debounceTimer = null\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state._sync.syncStack.updates).length\n          + state._sync.syncStack.deletions.length\n          + state._sync.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        state._sync.patching = 'error'\n        state._sync.syncStack.debounceTimer = null\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit, dispatch},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      const identifier = JSON.stringify({whereFilters, orderBy})\n      const fetched = state._sync.fetched[identifier]\n      // We've never fetched this before:\n      if (!fetched) {\n        let ref = getters.dbRef\n        // apply where filters and orderBy\n        whereFilters.forEach(paramsArr => {\n          ref = ref.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          ref = ref.orderBy(...orderBy)\n        }\n        state._sync.fetched[identifier] = {\n          ref,\n          done: false,\n          retrievedFetchRefs: [],\n          nextFetchRef: null\n        }\n      }\n      const fRequest = state._sync.fetched[identifier]\n      // We're already done fetching everything:\n      if (fRequest.done) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fRef = state._sync.fetched[identifier].ref\n      if (fRequest.nextFetchRef) {\n        // get next ref if saved in state\n        fRef = state._sync.fetched[identifier].nextFetchRef\n      }\n      fRef = fRef.limit(state._conf.fetch.docLimit)\n      // Stop if all records already fetched\n      if (fRequest.retrievedFetchRefs.includes(fRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          state._sync.fetched[identifier].done = true\n          resolve('fetchedAll')\n\n          return\n        }\n        if (docs.length < state._conf.fetch.docLimit) {\n          state._sync.fetched[identifier].done = true\n        }\n        state._sync.fetched[identifier].retrievedFetchRefs.push(fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fRef.startAfter(lastVisible)\n        state._sync.fetched[identifier].nextFetchRef = next\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const store = this\n    if (Firebase.auth().currentUser) state._sync.signedIn = true\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state._conf.firestoreRefType.toLowerCase() !== 'doc') {\n      state._conf.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state._conf.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state._conf.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn (_doc) {\n        return dispatch('serverUpdate', {change, id, doc: _doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state._conf.serverChange[change + 'Hook']\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, doc, id, store, source, change)\n      } else {\n        storeUpdateFn(doc)\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state._conf.serverChange.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state._conf.serverChange.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        state._sync.patching = 'error'\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (\n      !doc.id ||\n      (!state._conf.statePropName && !state[doc.id]) ||\n      (state._conf.statePropName && !state[state._conf.statePropName][doc.id])\n    ) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('INSERT_DOC', _doc)\n      return dispatch('insertDoc', _doc)\n    }\n    // check for hooks\n    if (state._conf.sync.insertHook) {\n      return state._conf.sync.insertHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patch ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {id: _doc.id, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patchBatch (\n    {state, getters, commit, dispatch},\n    {doc, ids = []}\n  ) {\n    const store = this\n    if (!doc) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {ids, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  delete ({state, getters, commit, dispatch}, id) {\n    const store = this\n    // define the store update\n    function storeUpdateFn (_id) {\n      commit('DELETE_DOC', _id)\n      return dispatch('deleteDoc', _id)\n    }\n    // check for hooks\n    if (state._conf.sync.deleteHook) {\n      return state._conf.sync.deleteHook(storeUpdateFn, id, store)\n    }\n    return storeUpdateFn(id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.stopPatchingTimeout = setTimeout(_ => { state._sync.patching = false }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.patching = true\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    return state._sync.signedIn\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    if (!Firebase.auth().currentUser) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state._conf.firestorePath.replace('{userId}', userId)\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state._conf.statePropName)\n      ? `${state._conf.moduleName}/${state._conf.statePropName}`\n      : state._conf.moduleName\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], doc = {}) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      let patchData = {}\n      // retrieve full object\n      if (!Object.keys(doc).length) {\n        patchData = (collectionMode)\n          ? getters.storeRef[id]\n          : getters.storeRef\n      } else {\n        patchData = doc\n      }\n      patchData = copyObj(patchData)\n      patchData = checkFillables(patchData, state._conf.sync.fillables, state._conf.sync.guard)\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      item = checkFillables(item, state._conf.sync.fillables, state._conf.sync.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'moduleName']\n  reqProps.forEach(prop => {\n    if (!config[prop]) {\n      console.error(`Missing ${prop} from your config!`)\n      return false\n    }\n  })\n  if (/(\\.|\\/)/.test(config.statePropName)) {\n    console.error(`statePropName must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleName)) {\n    console.error(`moduleName must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(defaultConfig, userConfig)\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.statePropName) docContainer[conf.statePropName] = {}\n  const state = merge(initialState, userState, docContainer, {_conf: conf})\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleName = getKeysFromPath(config.moduleName)\n      store.registerModule(moduleName, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.patchBatch = (path, payload) => {\n      return store.dispatch(path + '/patchBatch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["nanoclone","require","default","toArray","object","result","i","length","push","types","el","type","merger","a","b","keys","Object","concat","forEach","key","Array","isArray","Math","max","merge","config","is","determineType","strategy","name","arguments","reduceRight","element","wrapper","args","apply","l","item","isObject","error","deepmerge","updateStore","doc","store","id","source","change","mutations","state","_sync","syncStack","_conf","firestoreRefType","toLowerCase","statePropName","_vm","$set","newVal","undefined","docRef","$delete","userMutations","vuexEasyMutations","defaultMutations","assign","copyObj","obj","newObj","prototype","toString","call","JSON","parse","stringify","len","hasOwnProperty","defaultValues","ms","startTime","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","retrievePaths","path","reduce","carry","newPath","extra","actions","getters","dispatch","commit","ids","console","log","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","signedIn","debounceTimer","startDebounce","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","map","k","fields","updatesOK","slice","updatesLeft","flattenToPaths","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","patching","whereFilters","orderBy","identifier","fetched","ref","where","paramsArr","fRequest","fRef","nextFetchRef","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","fetchRef","lastVisible","next","startAfter","this","auth","currentUser","sync","handleDoc","storeUpdateFn","_doc","syncHookFn","serverChange","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","insertHook","patchHook","_id","deleteHook","stopPatchingTimeout","setTimeout","userActions","fillables","guard","rootState","rootGetters","userId","uid","firestorePath","replace","collection","moduleName","getDeepRef","patchData","checkFillables","storeRef","updated_at","FieldValue","serverTimestamp","items","created_at","created_by","userGetters","errorCheck","prop","test","userConfig","conf","defaultConfig","userState","docContainer","initialState","iniMutations","iniActions","iniGetters","createEasyFirestore","getKeysFromPath","registerModule","iniModule","setDoc","payload","insert","patch","patchBatch"],"mappings":"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"}