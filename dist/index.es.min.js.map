{"version":3,"file":"index.es.min.js","sources":["../src/utils/nanomerge.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/debounceHelper.js","../src/utils/objectFlattenToPaths.js","../src/module/actions.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/errorCheck.js","../src/module/index.js","../src/index.js"],"sourcesContent":["var nanoclone = require('nanoclone').default\n\nfunction toArray (object) {\n  var result = []\n\n  for (var i = 0; i < object.length; ++i) {\n    result.push(object[i])\n  }\n\n  return result\n}\n\nvar types = [\n  {\n    name: 'primitive',\n\n    is: function (el) {\n      var type = typeof el\n\n      return (type === 'number' || type === 'string' || type === 'boolean')\n    },\n\n    default: 'default',\n\n    merge: {\n      default: function (merger, a, b) {\n        return b\n      }\n    }\n  },\n\n  {\n    name: 'object',\n\n    is: function (el) {\n      return el !== null && (typeof el === 'object')\n    },\n\n    default: 'deep',\n\n    merge: {\n      deep: function (merger, a, b) {\n        var result = {}\n\n        var keys = {\n          a: Object.keys(a),\n          b: Object.keys(b)\n        }\n\n        keys.a.concat(keys.b).forEach(function (key) {\n          result[key] = merger(a[key], b[key])\n        })\n\n        return result\n      }\n    }\n  },\n\n  {\n    name: 'array',\n\n    is: function (el) {\n      return Array.isArray(el)\n    },\n\n    default: 'replace',\n\n    merge: {\n      merge: function (merger, a, b) {\n        var result = []\n\n        for (var i = 0; i < Math.max(a.length, b.length); ++i) {\n          result.push(merger(a[i], b[i]))\n        }\n\n        return result\n      },\n\n      replace: function (merger, a, b) {\n        return nanoclone(b)\n      },\n\n      concat: function (merger, a, b) {\n        return (([]).concat(a)).concat(b)\n      }\n    }\n  }\n]\n\nfunction merge (config) {\n  if (!config) {\n    config = {}\n  }\n\n  config = {\n    strategy: config.strategy || {}\n  }\n\n  function determineType (a, b) {\n    for (var i = types.length - 1; i >= 0; --i) {\n      var type = types[i]\n\n      if (type.is(a) && type.is(b)) {\n        return type\n      } else if (type.is(a) || type.is(b)) {\n        break\n      }\n    }\n\n    return null\n  }\n\n  function merger (a, b) {\n    if (b === void 0) {\n      return nanoclone(a)\n    }\n\n    var type = determineType(a, b)\n\n    if (!type) {\n      return nanoclone(b)\n    }\n\n    var strategy = config.strategy[type.name] || type.default\n\n    return type.merge[strategy](merger, a, b)\n  }\n\n  return function () {\n    var elements = toArray(arguments)\n\n    return elements.reduceRight(function (result, element) {\n      return merger(element, result)\n    })\n  }\n}\n\nfunction wrapper () {\n  var args = toArray(arguments)\n\n  // custom config\n  if (args.length === 1) {\n    return merge(args[0])\n  }\n\n  return merge().apply(null, args)\n}\n\nexport default wrapper\n// module.exports = wrapper\n","import { isObject } from 'is-what'\n// import deepmerge from 'nanomerge'\nimport deepmerge from './nanomerge'\n\nfunction merge (...params) {\n  let l = params.length\n  for (l; l > 0; l--) {\n    const item = params[l - 1]\n    if (!isObject(item)) {\n      console.error('trying to merge a non-object: ', item)\n      return item\n    }\n  }\n  return deepmerge(...params)\n}\n\nexport default merge\n","\nexport default {\n  firestorePath: '',\n    // The path to a collection or doc in firestore. You can use `{userId}` which will be replaced with the user Id.\n  firestoreRefType: '',\n    // `'collection'` or `'doc'`. Depending on your `firestorePath`.\n  moduleName: '',\n    // The module name. Can be nested, eg. `'user/items'`\n  statePropName: '',\n    // The name of the property where the docs or doc will be synced to. If left blank it will be synced on the state of the module. (Please see [Sync directly to module state](#sync-directly-to-module-state) for more info)\n\n  // Related to the 2-way sync:\n  sync: {\n    where: [],\n    orderBy: [],\n    fillables: [],\n    guard: [],\n    // HOOKS for local changes:\n    insertHook: function (updateStore, doc, store) { return updateStore(doc) },\n    patchHook: function (updateStore, doc, store) { return updateStore(doc) },\n    deleteHook: function (updateStore, id, store) { return updateStore(id) },\n  },\n\n  // When items on the server side are changed:\n  serverChange: {\n    defaultValues: {},\n    // HOOKS for changes on SERVER:\n    addedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    modifiedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    removedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n  },\n\n  // When items are fetched through `dispatch('module/fetch', filters)`.\n  fetch: {\n    // The max amount of documents to be fetched. Defaults to 50.\n    docLimit: 50,\n  },\n\n  // You can also add custom state/getters/mutations/actions. These will be added to your module.\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n}\n","\nexport default {\n  _sync: {\n    signedIn: false,\n    patching: false,\n    syncStack: {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    },\n    fetched: [],\n    stopPatchingTimeout: null\n  }\n}\n","import { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state._sync.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, doc)\n    } else {\n      this._vm.$set(state, doc.id, doc)\n    }\n  },\n  PATCH_DOC (state, doc) {\n    // When patching in single 'doc' mode\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') {\n      // if no target prop is the state\n      if (!state._conf.statePropName) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined || !isObject(state[key]) || !isObject(doc[key]))\n            ? doc[key]\n            : merge(state[key], doc[key])\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state._conf.statePropName] will always be an empty object by default\n      state[state._conf.statePropName] = merge(state[state._conf.statePropName], doc)\n      return\n    }\n    // Patching in 'collection' mode\n    // get the doc ref\n    const docRef = (state._conf.statePropName)\n      ? state[state._conf.statePropName][doc.id]\n      : state[doc.id]\n    // Merge if exists\n    const newVal = (docRef === undefined || !isObject(docRef) || !isObject(doc))\n      ? doc\n      : merge(docRef, doc)\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, newVal)\n    } else {\n      this._vm.$set(state, doc.id, newVal)\n    }\n  },\n  DELETE_DOC (state, id) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$delete(state[state._conf.statePropName], id)\n    } else {\n      this._vm.$delete(state, id)\n    }\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  return Object.assign({}, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","import { isObject } from 'is-what'\n\nfunction retrievePaths (object, path, result) {\n  if (!isObject(object) || !Object.keys(object).length) {\n    if (!path) return object\n    result[path] = object\n    return result\n  }\n  return Object.keys(object).reduce((carry, key) => {\n    const pathUntilNow = (path)\n      ? path + '.'\n      : ''\n    const newPath = pathUntilNow + key\n    const extra = retrievePaths(object[key], newPath, result)\n    return Object.assign(carry, extra)\n  }, {})\n}\n\nexport default function (object) {\n  const result = {}\n  return retrievePaths(object, null, result)\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\nimport flattenToPaths from '../utils/objectFlattenToPaths'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], doc} = {ids: [], doc: {}}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) return console.log('ids needs to be an array')\n    if (id) ids.push(id)\n    if (doc.id) delete doc.id\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, doc)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state._sync.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(state._sync.syncStack.updates[id],\n                syncStackItems[id])\n      state._sync.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state._sync.syncStack.deletions.concat(syncStackIds)\n    state._sync.syncStack.deletions = deletions\n\n    if (!state._sync.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state._sync.syncStack.inserts.concat(syncStack)\n    state._sync.syncStack.inserts = inserts\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state._sync.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      state._sync.syncStack.debounceTimer = debounceTimer\n    }\n    state._sync.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state._sync.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state._sync.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = flattenToPaths(item.fields)\n      console.log('fields â†’ ', fields)\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state._sync.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.deletions = deletionsLeft\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state._sync.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.inserts = insertsLeft\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    state._sync.syncStack.debounceTimer = null\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state._sync.syncStack.updates).length\n          + state._sync.syncStack.deletions.length\n          + state._sync.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        state._sync.patching = 'error'\n        state._sync.syncStack.debounceTimer = null\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit, dispatch},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      const identifier = JSON.stringify({whereFilters, orderBy})\n      const fetched = state._sync.fetched[identifier]\n      // We've never fetched this before:\n      if (!fetched) {\n        let ref = getters.dbRef\n        // apply where filters and orderBy\n        whereFilters.forEach(paramsArr => {\n          ref = ref.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          ref = ref.orderBy(...orderBy)\n        }\n        state._sync.fetched[identifier] = {\n          ref,\n          done: false,\n          retrievedFetchRefs: [],\n          nextFetchRef: null\n        }\n      }\n      const fRequest = state._sync.fetched[identifier]\n      // We're already done fetching everything:\n      if (fRequest.done) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fRef = state._sync.fetched[identifier].ref\n      if (fRequest.nextFetchRef) {\n        // get next ref if saved in state\n        fRef = state._sync.fetched[identifier].nextFetchRef\n      }\n      fRef = fRef.limit(state._conf.fetch.docLimit)\n      // Stop if all records already fetched\n      if (fRequest.retrievedFetchRefs.includes(fRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          state._sync.fetched[identifier].done = true\n          resolve('fetchedAll')\n\n          return\n        }\n        if (docs.length < state._conf.fetch.docLimit) {\n          state._sync.fetched[identifier].done = true\n        }\n        state._sync.fetched[identifier].retrievedFetchRefs.push(fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fRef.startAfter(lastVisible)\n        state._sync.fetched[identifier].nextFetchRef = next\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const store = this\n    if (Firebase.auth().currentUser) state._sync.signedIn = true\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state._conf.firestoreRefType.toLowerCase() !== 'doc') {\n      state._conf.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state._conf.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state._conf.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn (_doc) {\n        return dispatch('serverUpdate', {change, id, doc: _doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state._conf.serverChange[change + 'Hook']\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, doc, id, store, source, change)\n      } else {\n        storeUpdateFn(doc)\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state._conf.serverChange.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state._conf.serverChange.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        state._sync.patching = 'error'\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (\n      !doc.id ||\n      (!state._conf.statePropName && !state[doc.id]) ||\n      (state._conf.statePropName && !state[state._conf.statePropName][doc.id])\n    ) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('INSERT_DOC', _doc)\n      return dispatch('insertDoc', _doc)\n    }\n    // check for hooks\n    if (state._conf.sync.insertHook) {\n      return state._conf.sync.insertHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patch ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {id: _doc.id, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patchBatch (\n    {state, getters, commit, dispatch},\n    {doc, ids = []}\n  ) {\n    const store = this\n    if (!doc) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {ids, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  delete ({state, getters, commit, dispatch}, id) {\n    const store = this\n    // define the store update\n    function storeUpdateFn (_id) {\n      commit('DELETE_DOC', _id)\n      return dispatch('deleteDoc', _id)\n    }\n    // check for hooks\n    if (state._conf.sync.deleteHook) {\n      return state._conf.sync.deleteHook(storeUpdateFn, id, store)\n    }\n    return storeUpdateFn(id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.stopPatchingTimeout = setTimeout(_ => { state._sync.patching = false }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.patching = true\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    return state._sync.signedIn\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    if (!Firebase.auth().currentUser) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state._conf.firestorePath.replace('{userId}', userId)\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state._conf.statePropName)\n      ? `${state._conf.moduleName}/${state._conf.statePropName}`\n      : state._conf.moduleName\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], doc = {}) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      let patchData = {}\n      // retrieve full object\n      if (!Object.keys(doc).length) {\n        patchData = (collectionMode)\n          ? getters.storeRef[id]\n          : getters.storeRef\n      } else {\n        patchData = doc\n      }\n      patchData = copyObj(patchData)\n      patchData = checkFillables(patchData, state._conf.sync.fillables, state._conf.sync.guard)\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      item = checkFillables(item, state._conf.sync.fillables, state._conf.sync.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'moduleName']\n  reqProps.forEach(prop => {\n    if (!config[prop]) {\n      console.error(`Missing ${prop} from your config!`)\n      return false\n    }\n  })\n  if (/(\\.|\\/)/.test(config.statePropName)) {\n    console.error(`statePropName must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleName)) {\n    console.error(`moduleName must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(defaultConfig, userConfig)\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.statePropName) docContainer[conf.statePropName] = {}\n  const state = merge(initialState, userState, docContainer, {_conf: conf})\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleName = getKeysFromPath(config.moduleName)\n      store.registerModule(moduleName, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.patchBatch = (path, payload) => {\n      return store.dispatch(path + '/patchBatch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["nanoclone","require","default","toArray","object","result","i","length","push","types","el","type","merger","a","b","keys","Object","concat","forEach","key","Array","isArray","Math","max","merge","config","is","determineType","strategy","name","arguments","reduceRight","element","wrapper","args","apply","l","item","isObject","error","deepmerge","updateStore","doc","store","id","source","change","mutations","state","_sync","syncStack","_conf","firestoreRefType","toLowerCase","statePropName","_vm","$set","newVal","undefined","docRef","$delete","userMutations","assign","copyObj","obj","newObj","prototype","toString","call","JSON","parse","stringify","len","hasOwnProperty","defaultValues","ms","startTime","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","retrievePaths","path","reduce","carry","newPath","extra","actions","getters","dispatch","commit","ids","console","log","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","signedIn","debounceTimer","startDebounce","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","map","k","fields","updatesOK","slice","updatesLeft","flattenToPaths","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","patching","whereFilters","orderBy","identifier","fetched","ref","where","paramsArr","fRequest","fRef","nextFetchRef","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","fetchRef","lastVisible","next","startAfter","this","auth","currentUser","sync","handleDoc","storeUpdateFn","_doc","syncHookFn","serverChange","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","insertHook","patchHook","_id","deleteHook","stopPatchingTimeout","setTimeout","userActions","fillables","guard","rootState","rootGetters","userId","uid","firestorePath","replace","collection","moduleName","getDeepRef","patchData","checkFillables","storeRef","updated_at","FieldValue","serverTimestamp","items","created_at","created_by","userGetters","errorCheck","prop","test","userConfig","conf","defaultConfig","userState","docContainer","initialState","iniMutations","iniActions","iniGetters","createEasyFirestore","getKeysFromPath","registerModule","iniModule","setDoc","payload","insert","patch","patchBatch"],"mappings":"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"}